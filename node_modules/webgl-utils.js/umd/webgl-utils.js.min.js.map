{"version":3,"sources":["webpack://m3/webpack/universalModuleDefinition","webpack://m3/webpack/bootstrap","webpack://m3/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","error","msg","console","loadShader","gl","shaderSource","shaderType","opt_errorCallback","errFn","shader","createShader","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","createProgram","shaders","opt_attribs","opt_locations","program","forEach","attachShader","attrib","ndx","bindAttribLocation","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","createShaderFromScript","scriptId","opt_shaderType","shaderScript","document","getElementById","text","type","VERTEX_SHADER","FRAGMENT_SHADER","defaultShaderType","createProgramFromScripts","shaderScriptIds","ii","length","push","createProgramFromSources","shaderSources","getBindPointForSamplerType","SAMPLER_2D","TEXTURE_2D","SAMPLER_CUBE","TEXTURE_CUBE_MAP","createUniformSetters","textureUnit","createUniformSetter","uniformInfo","bindPoint","unit","location","getUniformLocation","isArray","size","substr","FLOAT","v","uniform1fv","uniform1f","FLOAT_VEC2","uniform2fv","FLOAT_VEC3","uniform3fv","FLOAT_VEC4","uniform4fv","INT","uniform1iv","uniform1i","INT_VEC2","uniform2iv","INT_VEC3","uniform3iv","INT_VEC4","uniform4iv","BOOL","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","FLOAT_MAT2","uniformMatrix2fv","FLOAT_MAT3","uniformMatrix3fv","FLOAT_MAT4","uniformMatrix4fv","units","info","textures","texture","index","activeTexture","TEXTURE0","bindTexture","toString","uniformSetters","numUniforms","ACTIVE_UNIFORMS","getActiveUniform","setter","setUniforms","setters","values","uniforms","keys","createAttributeSetters","attribSetters","createAttribSetter","b","disableVertexAttribArray","vertexAttrib4fv","vertexAttrib3fv","vertexAttrib2fv","vertexAttrib1fv","Error","bindBuffer","ARRAY_BUFFER","buffer","enableVertexAttribArray","vertexAttribPointer","numComponents","normalize","stride","offset","numAttribs","ACTIVE_ATTRIBUTES","attribInfo","getActiveAttrib","getAttribLocation","setAttributes","attribs","createVAOAndSetAttributes","indices","vao","createVertexArray","bindVertexArray","ELEMENT_ARRAY_BUFFER","createVAOFromBufferInfo","programInfo","bufferInfo","createProgramInfo","map","source","script","setBuffersAndAttributes","buffers","browserPrefixes","getExtensionWithKnownPrefixes","prefixedName","ext","getExtension","resizeCanvasToDisplaySize","canvas","multiplier","width","clientWidth","height","clientHeight","createAugmentedTypedArray","numElements","opt_type","typedArray","cursor","arguments","Array","ArrayBuffer","jj","reset","opt_index","this","augmentTypedArray","Float32Array","createBufferFromTypedArray","array","drawType","createBuffer","bufferData","STATIC_DRAW","allButIndices","getGLTypeForTypedArray","Int8Array","BYTE","Uint8Array","UNSIGNED_BYTE","Int16Array","SHORT","Uint16Array","UNSIGNED_SHORT","Int32Array","Uint32Array","UNSIGNED_INT","isArrayBuffer","a","guessNumComponentsFromName","indexOf","makeTypedArray","data","createAttribsFromArrays","arrays","opt_mapping","mapping","obj","filter","createMapping","attribName","bufferName","origArray","getArray","texcoordRE","colorRE","getNumComponents","arrayName","test","guessNumComponentsFromName2","origFn","positionKeys","createBufferInfoFromArrays","k","getNumElementsFromNonIndexedArrays","createBuffersFromArrays","position","drawBufferInfo","primitiveType","count","undefined","TRIANGLES","drawElements","drawArrays","drawObjectList","objectsToDraw","lastUsedProgramInfo","lastUsedBufferInfo","bindBuffers","useProgram","glEnumToString","results","join","documentMode","StyleMedia","HTMLCanvasElement","getContext","args","slice","apply"],"mappings":"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","file":"webgl-utils.js.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"m3\"] = factory();\n\telse\n\t\troot[\"m3\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*\n * Copyright 2012, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/** @module webgl-utils */\n\n/**\n * Wrapped logging function.\n * @param {string} msg The message to log.\n */\nfunction error(msg) {\n  console.error(msg);\n}\n\n\n/**\n * Error Callback\n * @callback ErrorCallback\n * @param {string} msg error message.\n * @memberOf module:webgl-utils\n */\n\n\n/**\n * Loads a shader.\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n * @param {string} shaderSource The shader source.\n * @param {number} shaderType The type of shader.\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.\n * @return {WebGLShader} The created shader.\n */\nfunction loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\n  const errFn = opt_errorCallback || error;\n  // Create the shader object\n  const shader = gl.createShader(shaderType);\n\n  // Load the shader source\n  gl.shaderSource(shader, shaderSource);\n\n  // Compile the shader\n  gl.compileShader(shader);\n\n  // Check the compile status\n  const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  if (!compiled) {\n    // Something went wrong during compilation; get the error\n    const lastError = gl.getShaderInfoLog(shader);\n    errFn('*** Error compiling shader \\'' + shader + '\\':' + lastError);\n    gl.deleteShader(shader);\n    return null;\n  }\n\n  return shader;\n}\n\n/**\n * Creates a program, attaches shaders, binds attrib locations, links the\n * program and calls useProgram.\n * @param {WebGLShader[]} shaders The shaders to attach\n * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n *        on error. If you want something else pass an callback. It's passed an error message.\n * @memberOf module:webgl-utils\n */\nfunction createProgram(\n  gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {\n  const errFn = opt_errorCallback || error;\n  const program = gl.createProgram();\n  shaders.forEach(function (shader) {\n    gl.attachShader(program, shader);\n  });\n  if (opt_attribs) {\n    opt_attribs.forEach(function (attrib, ndx) {\n      gl.bindAttribLocation(\n        program,\n        opt_locations ? opt_locations[ndx] : ndx,\n        attrib);\n    });\n  }\n  gl.linkProgram(program);\n\n  // Check the link status\n  const linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!linked) {\n    // something went wrong with the link\n    const lastError = gl.getProgramInfoLog(program);\n    errFn('Error in program linking:' + lastError);\n\n    gl.deleteProgram(program);\n    return null;\n  }\n  return program;\n}\n\n/**\n * Loads a shader from a script tag.\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n * @param {string} scriptId The id of the script tag.\n * @param {number} opt_shaderType The type of shader. If not passed in it will\n *     be derived from the type of the script tag.\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.\n * @return {WebGLShader} The created shader.\n */\nfunction createShaderFromScript(\n  gl, scriptId, opt_shaderType, opt_errorCallback) {\n  let shaderSource = '';\n  let shaderType;\n  const shaderScript = document.getElementById(scriptId);\n  if (!shaderScript) {\n    throw ('*** Error: unknown script element' + scriptId);\n  }\n  shaderSource = shaderScript.text;\n\n  if (!opt_shaderType) {\n    if (shaderScript.type === 'x-shader/x-vertex') {\n      shaderType = gl.VERTEX_SHADER;\n    } else if (shaderScript.type === 'x-shader/x-fragment') {\n      shaderType = gl.FRAGMENT_SHADER;\n    } else if (shaderType !== gl.VERTEX_SHADER && shaderType !== gl.FRAGMENT_SHADER) {\n      throw ('*** Error: unknown shader type');\n    }\n  }\n\n  return loadShader(\n    gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType,\n    opt_errorCallback);\n}\n\nconst defaultShaderType = [\n  'VERTEX_SHADER',\n  'FRAGMENT_SHADER',\n];\n\n/**\n * Creates a program from 2 script tags.\n *\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n *        to use.\n * @param {string[]} shaderScriptIds Array of ids of the script\n *        tags for the shaders. The first is assumed to be the\n *        vertex shader, the second the fragment shader.\n * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n *        on error. If you want something else pass an callback. It's passed an error message.\n * @return {WebGLProgram} The created program.\n * @memberOf module:webgl-utils\n */\nfunction createProgramFromScripts(\n  gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {\n  const shaders = [];\n  for (let ii = 0; ii < shaderScriptIds.length; ++ii) {\n    shaders.push(createShaderFromScript(\n      gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], opt_errorCallback));\n  }\n  return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\n}\n\n/**\n * Creates a program from 2 sources.\n *\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n *        to use.\n * @param {string[]} shaderSourcess Array of sources for the\n *        shaders. The first is assumed to be the vertex shader,\n *        the second the fragment shader.\n * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n *        on error. If you want something else pass an callback. It's passed an error message.\n * @return {WebGLProgram} The created program.\n * @memberOf module:webgl-utils\n */\nfunction createProgramFromSources(\n  gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n  const shaders = [];\n  for (let ii = 0; ii < shaderSources.length; ++ii) {\n    shaders.push(loadShader(\n      gl, shaderSources[ii], gl[defaultShaderType[ii]], opt_errorCallback));\n  }\n  return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\n}\n\n/**\n * Returns the corresponding bind point for a given sampler type\n */\nfunction getBindPointForSamplerType(gl, type) {\n  if (type === gl.SAMPLER_2D) return gl.TEXTURE_2D;        // eslint-disable-line\n  if (type === gl.SAMPLER_CUBE) return gl.TEXTURE_CUBE_MAP;  // eslint-disable-line\n  return undefined;\n}\n\n/**\n * @typedef {Object.<string, function>} Setters\n */\n\n/**\n * Creates setter functions for all uniforms of a shader\n * program.\n *\n * @see {@link module:webgl-utils.setUniforms}\n *\n * @param {WebGLProgram} program the program to create setters for.\n * @returns {Object.<string, function>} an object with a setter by name for each uniform\n * @memberOf module:webgl-utils\n */\nfunction createUniformSetters(gl, program) {\n  let textureUnit = 0;\n\n  /**\n   * Creates a setter for a uniform of the given program with it's\n   * location embedded in the setter.\n   * @param {WebGLProgram} program\n   * @param {WebGLUniformInfo} uniformInfo\n   * @returns {function} the created setter.\n   */\n  function createUniformSetter(program, uniformInfo) {\n    const location = gl.getUniformLocation(program, uniformInfo.name);\n    const type = uniformInfo.type;\n    // Check if this uniform is an array\n    const isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === '[0]');\n    if (type === gl.FLOAT && isArray) {\n      return function (v) {\n        gl.uniform1fv(location, v);\n      };\n    }\n    if (type === gl.FLOAT) {\n      return function (v) {\n        gl.uniform1f(location, v);\n      };\n    }\n    if (type === gl.FLOAT_VEC2) {\n      return function (v) {\n        gl.uniform2fv(location, v);\n      };\n    }\n    if (type === gl.FLOAT_VEC3) {\n      return function (v) {\n        gl.uniform3fv(location, v);\n      };\n    }\n    if (type === gl.FLOAT_VEC4) {\n      return function (v) {\n        gl.uniform4fv(location, v);\n      };\n    }\n    if (type === gl.INT && isArray) {\n      return function (v) {\n        gl.uniform1iv(location, v);\n      };\n    }\n    if (type === gl.INT) {\n      return function (v) {\n        gl.uniform1i(location, v);\n      };\n    }\n    if (type === gl.INT_VEC2) {\n      return function (v) {\n        gl.uniform2iv(location, v);\n      };\n    }\n    if (type === gl.INT_VEC3) {\n      return function (v) {\n        gl.uniform3iv(location, v);\n      };\n    }\n    if (type === gl.INT_VEC4) {\n      return function (v) {\n        gl.uniform4iv(location, v);\n      };\n    }\n    if (type === gl.BOOL) {\n      return function (v) {\n        gl.uniform1iv(location, v);\n      };\n    }\n    if (type === gl.BOOL_VEC2) {\n      return function (v) {\n        gl.uniform2iv(location, v);\n      };\n    }\n    if (type === gl.BOOL_VEC3) {\n      return function (v) {\n        gl.uniform3iv(location, v);\n      };\n    }\n    if (type === gl.BOOL_VEC4) {\n      return function (v) {\n        gl.uniform4iv(location, v);\n      };\n    }\n    if (type === gl.FLOAT_MAT2) {\n      return function (v) {\n        gl.uniformMatrix2fv(location, false, v);\n      };\n    }\n    if (type === gl.FLOAT_MAT3) {\n      return function (v) {\n        gl.uniformMatrix3fv(location, false, v);\n      };\n    }\n    if (type === gl.FLOAT_MAT4) {\n      return function (v) {\n        gl.uniformMatrix4fv(location, false, v);\n      };\n    }\n    if ((type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) && isArray) {\n      const units = [];\n      for (let ii = 0; ii < info.size; ++ii) {\n        units.push(textureUnit++);\n      }\n      return function (bindPoint, units) {\n        return function (textures) {\n          gl.uniform1iv(location, units);\n          textures.forEach(function (texture, index) {\n            gl.activeTexture(gl.TEXTURE0 + units[index]);\n            gl.bindTexture(bindPoint, texture);\n          });\n        };\n      }(getBindPointForSamplerType(gl, type), units);\n    }\n    if (type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) {\n      return function (bindPoint, unit) {\n        return function (texture) {\n          gl.uniform1i(location, unit);\n          gl.activeTexture(gl.TEXTURE0 + unit);\n          gl.bindTexture(bindPoint, texture);\n        };\n      }(getBindPointForSamplerType(gl, type), textureUnit++);\n    }\n    throw ('unknown type: 0x' + type.toString(16)); // we should never get here.\n  }\n\n  const uniformSetters = {};\n  const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n  for (let ii = 0; ii < numUniforms; ++ii) {\n    const uniformInfo = gl.getActiveUniform(program, ii);\n    if (!uniformInfo) {\n      break;\n    }\n    let name = uniformInfo.name;\n    // remove the array suffix.\n    if (name.substr(-3) === '[0]') {\n      name = name.substr(0, name.length - 3);\n    }\n    const setter = createUniformSetter(program, uniformInfo);\n    uniformSetters[name] = setter;\n  }\n  return uniformSetters;\n}\n\n/**\n * Set uniforms and binds related textures.\n *\n * Example:\n *\n *     let programInfo = createProgramInfo(\n *         gl, [\"some-vs\", \"some-fs\"]);\n *\n *     let tex1 = gl.createTexture();\n *     let tex2 = gl.createTexture();\n *\n *     ... assume we setup the textures with data ...\n *\n *     let uniforms = {\n *       u_someSampler: tex1,\n *       u_someOtherSampler: tex2,\n *       u_someColor: [1,0,0,1],\n *       u_somePosition: [0,1,1],\n *       u_someMatrix: [\n *         1,0,0,0,\n *         0,1,0,0,\n *         0,0,1,0,\n *         0,0,0,0,\n *       ],\n *     };\n *\n *     gl.useProgram(program);\n *\n * This will automatically bind the textures AND set the\n * uniforms.\n *\n *     setUniforms(programInfo.uniformSetters, uniforms);\n *\n * For the example above it is equivalent to\n *\n *     let texUnit = 0;\n *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n *     gl.bindTexture(gl.TEXTURE_2D, tex1);\n *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n *     gl.bindTexture(gl.TEXTURE_2D, tex2);\n *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);\n *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);\n *     gl.uniformMatrix4fv(u_someMatrix, false, [\n *         1,0,0,0,\n *         0,1,0,0,\n *         0,0,1,0,\n *         0,0,0,0,\n *       ]);\n *\n * Note it is perfectly reasonable to call `setUniforms` multiple times. For example\n *\n *     let uniforms = {\n *       u_someSampler: tex1,\n *       u_someOtherSampler: tex2,\n *     };\n *\n *     let moreUniforms {\n *       u_someColor: [1,0,0,1],\n *       u_somePosition: [0,1,1],\n *       u_someMatrix: [\n *         1,0,0,0,\n *         0,1,0,0,\n *         0,0,1,0,\n *         0,0,0,0,\n *       ],\n *     };\n *\n *     setUniforms(programInfo.uniformSetters, uniforms);\n *     setUniforms(programInfo.uniformSetters, moreUniforms);\n *\n * @param {Object.<string, function>|module:webgl-utils.ProgramInfo} setters the setters returned from\n *        `createUniformSetters` or a ProgramInfo from {@link module:webgl-utils.createProgramInfo}.\n * @param {Object.<string, value>} an object with values for the\n *        uniforms.\n * @memberOf module:webgl-utils\n */\nfunction setUniforms(setters, ...values) {\n  setters = setters.uniformSetters || setters;\n  for (const uniforms of values) {\n    Object.keys(uniforms).forEach(function (name) {\n      const setter = setters[name];\n      if (setter) {\n        setter(uniforms[name]);\n      }\n    });\n  }\n}\n\n/**\n * Creates setter functions for all attributes of a shader\n * program. You can pass this to {@link module:webgl-utils.setBuffersAndAttributes} to set all your buffers and attributes.\n *\n * @see {@link module:webgl-utils.setAttributes} for example\n * @param {WebGLProgram} program the program to create setters for.\n * @return {Object.<string, function>} an object with a setter for each attribute by name.\n * @memberOf module:webgl-utils\n */\nfunction createAttributeSetters(gl, program) {\n  const attribSetters = {\n  };\n\n  function createAttribSetter(index) {\n    return function (b) {\n      if (b.value) {\n        gl.disableVertexAttribArray(index);\n        switch (b.value.length) {\n          case 4:\n            gl.vertexAttrib4fv(index, b.value);\n            break;\n          case 3:\n            gl.vertexAttrib3fv(index, b.value);\n            break;\n          case 2:\n            gl.vertexAttrib2fv(index, b.value);\n            break;\n          case 1:\n            gl.vertexAttrib1fv(index, b.value);\n            break;\n          default:\n            throw new Error('the length of a float constant value must be between 1 and 4!');\n        }\n      } else {\n        gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n        gl.enableVertexAttribArray(index);\n        gl.vertexAttribPointer(\n          index, b.numComponents || b.size, b.type || gl.FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);\n      }\n    };\n  }\n\n  const numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n  for (let ii = 0; ii < numAttribs; ++ii) {\n    const attribInfo = gl.getActiveAttrib(program, ii);\n    if (!attribInfo) {\n      break;\n    }\n    const index = gl.getAttribLocation(program, attribInfo.name);\n    attribSetters[attribInfo.name] = createAttribSetter(index);\n  }\n\n  return attribSetters;\n}\n\n/**\n * Sets attributes and binds buffers (deprecated... use {@link module:webgl-utils.setBuffersAndAttributes})\n *\n * Example:\n *\n *     let program = createProgramFromScripts(\n *         gl, [\"some-vs\", \"some-fs\"]);\n *\n *     let attribSetters = createAttributeSetters(program);\n *\n *     let positionBuffer = gl.createBuffer();\n *     let texcoordBuffer = gl.createBuffer();\n *\n *     let attribs = {\n *       a_position: {buffer: positionBuffer, numComponents: 3},\n *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n *     };\n *\n *     gl.useProgram(program);\n *\n * This will automatically bind the buffers AND set the\n * attributes.\n *\n *     setAttributes(attribSetters, attribs);\n *\n * Properties of attribs. For each attrib you can add\n * properties:\n *\n * *   type: the type of data in the buffer. Default = gl.FLOAT\n * *   normalize: whether or not to normalize the data. Default = false\n * *   stride: the stride. Default = 0\n * *   offset: offset into the buffer. Default = 0\n *\n * For example if you had 3 value float positions, 2 value\n * float texcoord and 4 value uint8 colors you'd setup your\n * attribs like this\n *\n *     let attribs = {\n *       a_position: {buffer: positionBuffer, numComponents: 3},\n *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n *       a_color: {\n *         buffer: colorBuffer,\n *         numComponents: 4,\n *         type: gl.UNSIGNED_BYTE,\n *         normalize: true,\n *       },\n *     };\n *\n * @param {Object.<string, function>|model:webgl-utils.ProgramInfo} setters Attribute setters as returned from createAttributeSetters or a ProgramInfo as returned {@link module:webgl-utils.createProgramInfo}\n * @param {Object.<string, module:webgl-utils.AttribInfo>} attribs AttribInfos mapped by attribute name.\n * @memberOf module:webgl-utils\n * @deprecated use {@link module:webgl-utils.setBuffersAndAttributes}\n */\nfunction setAttributes(setters, attribs) {\n  setters = setters.attribSetters || setters;\n  Object.keys(attribs).forEach(function (name) {\n    const setter = setters[name];\n    if (setter) {\n      setter(attribs[name]);\n    }\n  });\n}\n\n/**\n * Creates a vertex array object and then sets the attributes\n * on it\n *\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n *        to use.\n * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters\n * @param {Object.<string, module:webgl-utils.AttribInfo>} attribs AttribInfos mapped by attribute name.\n * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices\n */\nfunction createVAOAndSetAttributes(gl, setters, attribs, indices) {\n  const vao = gl.createVertexArray();\n  gl.bindVertexArray(vao);\n  setAttributes(setters, attribs);\n  if (indices) {\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n  }\n  // We unbind this because otherwise any change to ELEMENT_ARRAY_BUFFER\n  // like when creating buffers for other stuff will mess up this VAO's binding\n  gl.bindVertexArray(null);\n  return vao;\n}\n\n/**\n * Creates a vertex array object and then sets the attributes\n * on it\n *\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n *        to use.\n * @param {Object.<string, function>| module:webgl-utils.ProgramInfo} programInfo as returned from createProgramInfo or Attribute setters as returned from createAttributeSetters\n * @param {module:webgl-utils:BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...\n * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices\n */\nfunction createVAOFromBufferInfo(gl, programInfo, bufferInfo) {\n  return createVAOAndSetAttributes(gl, programInfo.attribSetters || programInfo, bufferInfo.attribs, bufferInfo.indices);\n}\n\n/**\n * @typedef {Object} ProgramInfo\n * @property {WebGLProgram} program A shader program\n * @property {Object<string, function>} uniformSetters: object of setters as returned from createUniformSetters,\n * @property {Object<string, function>} attribSetters: object of setters as returned from createAttribSetters,\n * @memberOf module:webgl-utils\n */\n\n/**\n * Creates a ProgramInfo from 2 sources.\n *\n * A ProgramInfo contains\n *\n *     programInfo = {\n *        program: WebGLProgram,\n *        uniformSetters: object of setters as returned from createUniformSetters,\n *        attribSetters: object of setters as returned from createAttribSetters,\n *     }\n *\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n *        to use.\n * @param {string[]} shaderSourcess Array of sources for the\n *        shaders or ids. The first is assumed to be the vertex shader,\n *        the second the fragment shader.\n * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n *        on error. If you want something else pass an callback. It's passed an error message.\n * @return {module:webgl-utils.ProgramInfo} The created program.\n * @memberOf module:webgl-utils\n */\nfunction createProgramInfo(\n  gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n  shaderSources = shaderSources.map(function (source) {\n    const script = document.getElementById(source);\n    return script ? script.text : source;\n  });\n  const program = createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback);\n  if (!program) {\n    return null;\n  }\n  const uniformSetters = createUniformSetters(gl, program);\n  const attribSetters = createAttributeSetters(gl, program);\n  return {\n    program: program,\n    uniformSetters: uniformSetters,\n    attribSetters: attribSetters,\n  };\n}\n\n/**\n * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate\n *\n * Example:\n *\n *     let programInfo = createProgramInfo(\n *         gl, [\"some-vs\", \"some-fs\"]);\n *\n *     let arrays = {\n *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n *     };\n *\n *     let bufferInfo = createBufferInfoFromArrays(gl, arrays);\n *\n *     gl.useProgram(programInfo.program);\n *\n * This will automatically bind the buffers AND set the\n * attributes.\n *\n *     setBuffersAndAttributes(programInfo.attribSetters, bufferInfo);\n *\n * For the example above it is equivilent to\n *\n *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n *     gl.enableVertexAttribArray(a_positionLocation);\n *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);\n *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n *     gl.enableVertexAttribArray(a_texcoordLocation);\n *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);\n *\n * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n * @param {Object.<string, function>} setters Attribute setters as returned from `createAttributeSetters`\n * @param {module:webgl-utils.BufferInfo} buffers a BufferInfo as returned from `createBufferInfoFromArrays`.\n * @memberOf module:webgl-utils\n */\nfunction setBuffersAndAttributes(gl, setters, buffers) {\n  setAttributes(setters, buffers.attribs);\n  if (buffers.indices) {\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\n  }\n}\n\n// Add your prefix here.\nconst browserPrefixes = [\n  '',\n  'MOZ_',\n  'OP_',\n  'WEBKIT_',\n];\n\n/**\n * Given an extension name like WEBGL_compressed_texture_s3tc\n * returns the supported version extension, like\n * WEBKIT_WEBGL_compressed_teture_s3tc\n * @param {string} name Name of extension to look for\n * @return {WebGLExtension} The extension or undefined if not\n *     found.\n * @memberOf module:webgl-utils\n */\nfunction getExtensionWithKnownPrefixes(gl, name) {\n  for (let ii = 0; ii < browserPrefixes.length; ++ii) {\n    const prefixedName = browserPrefixes[ii] + name;\n    const ext = gl.getExtension(prefixedName);\n    if (ext) {\n      return ext;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Resize a canvas to match the size its displayed.\n * @param {HTMLCanvasElement} canvas The canvas to resize.\n * @param {number} [multiplier] amount to multiply by.\n *    Pass in window.devicePixelRatio for native pixels.\n * @return {boolean} true if the canvas was resized.\n * @memberOf module:webgl-utils\n */\nfunction resizeCanvasToDisplaySize(canvas, multiplier) {\n  multiplier = multiplier || 1;\n  const width = canvas.clientWidth * multiplier | 0;\n  const height = canvas.clientHeight * multiplier | 0;\n  if (canvas.width !== width || canvas.height !== height) {\n    canvas.width = width;\n    canvas.height = height;\n    return true;\n  }\n  return false;\n}\n\n// Add `push` to a typed array. It just keeps a 'cursor'\n// and allows use to `push` values into the array so we\n// don't have to manually compute offsets\nfunction augmentTypedArray(typedArray, numComponents) {\n  let cursor = 0;\n  typedArray.push = function () {\n    for (let ii = 0; ii < arguments.length; ++ii) {\n      const value = arguments[ii];\n      if (value instanceof Array || (value.buffer && value.buffer instanceof ArrayBuffer)) {\n        for (let jj = 0; jj < value.length; ++jj) {\n          typedArray[cursor++] = value[jj];\n        }\n      } else {\n        typedArray[cursor++] = value;\n      }\n    }\n  };\n  typedArray.reset = function (opt_index) {\n    cursor = opt_index || 0;\n  };\n  typedArray.numComponents = numComponents;\n  Object.defineProperty(typedArray, 'numElements', {\n    get: function () {\n      return this.length / this.numComponents | 0;\n    },\n  });\n  return typedArray;\n}\n\n/**\n * creates a typed array with a `push` function attached\n * so that you can easily *push* values.\n *\n * `push` can take multiple arguments. If an argument is an array each element\n * of the array will be added to the typed array.\n *\n * Example:\n *\n *     let array = createAugmentedTypedArray(3, 2);  // creates a Float32Array with 6 values\n *     array.push(1, 2, 3);\n *     array.push([4, 5, 6]);\n *     // array now contains [1, 2, 3, 4, 5, 6]\n *\n * Also has `numComponents` and `numElements` properties.\n *\n * @param {number} numComponents number of components\n * @param {number} numElements number of elements. The total size of the array will be `numComponents * numElements`.\n * @param {constructor} opt_type A constructor for the type. Default = `Float32Array`.\n * @return {ArrayBuffer} A typed array.\n * @memberOf module:webgl-utils\n */\nfunction createAugmentedTypedArray(numComponents, numElements, opt_type) {\n  const Type = opt_type || Float32Array;\n  return augmentTypedArray(new Type(numComponents * numElements), numComponents);\n}\n\nfunction createBufferFromTypedArray(gl, array, type, drawType) {\n  type = type || gl.ARRAY_BUFFER;\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(type, buffer);\n  gl.bufferData(type, array, drawType || gl.STATIC_DRAW);\n  return buffer;\n}\n\nfunction allButIndices(name) {\n  return name !== 'indices';\n}\n\nfunction createMapping(obj) {\n  const mapping = {};\n  Object.keys(obj).filter(allButIndices).forEach(function (key) {\n    mapping['a_' + key] = key;\n  });\n  return mapping;\n}\n\nfunction getGLTypeForTypedArray(gl, typedArray) {\n  if (typedArray instanceof Int8Array) { return gl.BYTE; }            // eslint-disable-line\n  if (typedArray instanceof Uint8Array) { return gl.UNSIGNED_BYTE; }   // eslint-disable-line\n  if (typedArray instanceof Int16Array) { return gl.SHORT; }           // eslint-disable-line\n  if (typedArray instanceof Uint16Array) { return gl.UNSIGNED_SHORT; }  // eslint-disable-line\n  if (typedArray instanceof Int32Array) { return gl.INT; }             // eslint-disable-line\n  if (typedArray instanceof Uint32Array) { return gl.UNSIGNED_INT; }    // eslint-disable-line\n  if (typedArray instanceof Float32Array) { return gl.FLOAT; }           // eslint-disable-line\n  throw 'unsupported typed array type';\n}\n\n// This is really just a guess. Though I can't really imagine using\n// anything else? Maybe for some compression?\nfunction getNormalizationForTypedArray(typedArray) {\n  if (typedArray instanceof Int8Array) { return true; }  // eslint-disable-line\n  if (typedArray instanceof Uint8Array) { return true; }  // eslint-disable-line\n  return false;\n}\n\nfunction isArrayBuffer(a) {\n  return a.buffer && a.buffer instanceof ArrayBuffer;\n}\n\nfunction guessNumComponentsFromName(name, length) {\n  let numComponents;\n  if (name.indexOf('coord') >= 0) {\n    numComponents = 2;\n  } else if (name.indexOf('color') >= 0) {\n    numComponents = 4;\n  } else {\n    numComponents = 3;  // position, normals, indices ...\n  }\n\n  if (length % numComponents > 0) {\n    throw 'can not guess numComponents. You should specify it.';\n  }\n\n  return numComponents;\n}\n\nfunction makeTypedArray(array, name) {\n  if (isArrayBuffer(array)) {\n    return array;\n  }\n\n  if (array.data && isArrayBuffer(array.data)) {\n    return array.data;\n  }\n\n  if (Array.isArray(array)) {\n    array = {\n      data: array,\n    };\n  }\n\n  if (!array.numComponents) {\n    array.numComponents = guessNumComponentsFromName(name, array.length);\n  }\n\n  let type = array.type;\n  if (!type) {\n    if (name === 'indices') {\n      type = Uint16Array;\n    }\n  }\n  const typedArray = createAugmentedTypedArray(array.numComponents, array.data.length / array.numComponents | 0, type);\n  typedArray.push(array.data);\n  return typedArray;\n}\n\n/**\n * @typedef {Object} AttribInfo\n * @property {number} [numComponents] the number of components for this attribute.\n * @property {number} [size] the number of components for this attribute.\n * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`\n * @property {boolean} [normalized] whether or not to normalize the data. Default = false\n * @property {number} [offset] offset into buffer in bytes. Default = 0\n * @property {number} [stride] the stride in bytes per element. Default = 0\n * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute\n * @memberOf module:webgl-utils\n */\n\n\n/**\n * Creates a set of attribute data and WebGLBuffers from set of arrays\n *\n * Given\n *\n *      let arrays = {\n *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },\n *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n *      };\n *\n * returns something like\n *\n *      let attribs = {\n *        a_position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n *        a_texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n *        a_normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n *        a_color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },\n *      };\n *\n * @param {WebGLRenderingContext} gl The webgl rendering context.\n * @param {Object.<string, array|typedarray>} arrays The arrays\n * @param {Object.<string, string>} [opt_mapping] mapping from attribute name to array name.\n *     if not specified defaults to \"a_name\" -> \"name\".\n * @return {Object.<string, module:webgl-utils.AttribInfo>} the attribs\n * @memberOf module:webgl-utils\n */\nfunction createAttribsFromArrays(gl, arrays, opt_mapping) {\n  const mapping = opt_mapping || createMapping(arrays);\n  const attribs = {};\n  Object.keys(mapping).forEach(function (attribName) {\n    const bufferName = mapping[attribName];\n    const origArray = arrays[bufferName];\n    if (origArray.value) {\n      attribs[attribName] = {\n        value: origArray.value,\n      };\n    } else {\n      const array = makeTypedArray(origArray, bufferName);\n      attribs[attribName] = {\n        buffer: createBufferFromTypedArray(gl, array),\n        numComponents: origArray.numComponents || array.numComponents || guessNumComponentsFromName(bufferName),\n        type: getGLTypeForTypedArray(gl, array),\n        normalize: getNormalizationForTypedArray(array),\n      };\n    }\n  });\n  return attribs;\n}\n\nfunction getArray(array) {\n  return array.length ? array : array.data;\n}\n\nconst texcoordRE = /coord|texture/i;\nconst colorRE = /color|colour/i;\n\nfunction guessNumComponentsFromName2(name, length) {\n  let numComponents;\n  if (texcoordRE.test(name)) {\n    numComponents = 2;\n  } else if (colorRE.test(name)) {\n    numComponents = 4;\n  } else {\n    numComponents = 3;  // position, normals, indices ...\n  }\n\n  if (length % numComponents > 0) {\n    throw new Error(`Can not guess numComponents for attribute '${name}'. Tried ${numComponents} but ${length} values is not evenly divisible by ${numComponents}. You should specify it.`);\n  }\n\n  return numComponents;\n}\n\nfunction getNumComponents(array, arrayName) {\n  return array.numComponents || array.size || guessNumComponentsFromName2(arrayName, getArray(array).length);\n}\n\n/**\n * tries to get the number of elements from a set of arrays.\n */\nconst positionKeys = ['position', 'positions', 'a_position'];\nfunction getNumElementsFromNonIndexedArrays(arrays) {\n  let key;\n  for (const k of positionKeys) {\n    if (k in arrays) {\n      key = k;\n      break;\n    }\n  }\n  key = key || Object.keys(arrays)[0];\n  const array = arrays[key];\n  const length = getArray(array).length;\n  const numComponents = getNumComponents(array, key);\n  const numElements = length / numComponents;\n  if (length % numComponents > 0) {\n    throw new Error(`numComponents ${numComponents} not correct for length ${length}`);\n  }\n  return numElements;\n}\n\n/**\n * @typedef {Object} BufferInfo\n * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.\n * @property {Object.<string, module:webgl-utils.AttribInfo>} attribs The attribs approriate to call `setAttributes`\n * @memberOf module:webgl-utils\n */\n\n\n/**\n * Creates a BufferInfo from an object of arrays.\n *\n * This can be passed to {@link module:webgl-utils.setBuffersAndAttributes} and to\n * {@link module:webgl-utils:drawBufferInfo}.\n *\n * Given an object like\n *\n *     let arrays = {\n *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n *     };\n *\n *  Creates an BufferInfo like this\n *\n *     bufferInfo = {\n *       numElements: 4,        // or whatever the number of elements is\n *       indices: WebGLBuffer,  // this property will not exist if there are no indices\n *       attribs: {\n *         a_position: { buffer: WebGLBuffer, numComponents: 3, },\n *         a_normal:   { buffer: WebGLBuffer, numComponents: 3, },\n *         a_texcoord: { buffer: WebGLBuffer, numComponents: 2, },\n *       },\n *     };\n *\n *  The properties of arrays can be JavaScript arrays in which case the number of components\n *  will be guessed.\n *\n *     let arrays = {\n *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],\n *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],\n *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],\n *        indices:  [0, 1, 2, 1, 2, 3],\n *     };\n *\n *  They can also by TypedArrays\n *\n *     let arrays = {\n *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n *     };\n *\n *  Or augmentedTypedArrays\n *\n *     let positions = createAugmentedTypedArray(3, 4);\n *     let texcoords = createAugmentedTypedArray(2, 4);\n *     let normals   = createAugmentedTypedArray(3, 4);\n *     let indices   = createAugmentedTypedArray(3, 2, Uint16Array);\n *\n *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);\n *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);\n *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);\n *     indices.push([0, 1, 2, 1, 2, 3]);\n *\n *     let arrays = {\n *        position: positions,\n *        texcoord: texcoords,\n *        normal:   normals,\n *        indices:  indices,\n *     };\n *\n * For the last example it is equivalent to\n *\n *     let bufferInfo = {\n *       attribs: {\n *         a_position: { numComponents: 3, buffer: gl.createBuffer(), },\n *         a_texcoods: { numComponents: 2, buffer: gl.createBuffer(), },\n *         a_normals: { numComponents: 3, buffer: gl.createBuffer(), },\n *       },\n *       indices: gl.createBuffer(),\n *       numElements: 6,\n *     };\n *\n *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_position.buffer);\n *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);\n *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_texcoord.buffer);\n *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);\n *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_normal.buffer);\n *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);\n *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);\n *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);\n *\n * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n * @param {Object.<string, array|object|typedarray>} arrays Your data\n * @param {Object.<string, string>} [opt_mapping] an optional mapping of attribute to array name.\n *    If not passed in it's assumed the array names will be mapped to an attribute\n *    of the same name with \"a_\" prefixed to it. An other words.\n *\n *        let arrays = {\n *           position: ...,\n *           texcoord: ...,\n *           normal:   ...,\n *           indices:  ...,\n *        };\n *\n *        bufferInfo = createBufferInfoFromArrays(gl, arrays);\n *\n *    Is the same as\n *\n *        let arrays = {\n *           position: ...,\n *           texcoord: ...,\n *           normal:   ...,\n *           indices:  ...,\n *        };\n *\n *        let mapping = {\n *          a_position: \"position\",\n *          a_texcoord: \"texcoord\",\n *          a_normal:   \"normal\",\n *        };\n *\n *        bufferInfo = createBufferInfoFromArrays(gl, arrays, mapping);\n *\n * @return {module:webgl-utils.BufferInfo} A BufferInfo\n * @memberOf module:webgl-utils\n */\nfunction createBufferInfoFromArrays(gl, arrays, opt_mapping) {\n  const bufferInfo = {\n    attribs: createAttribsFromArrays(gl, arrays, opt_mapping),\n  };\n  let indices = arrays.indices;\n  if (indices) {\n    indices = makeTypedArray(indices, 'indices');\n    bufferInfo.indices = createBufferFromTypedArray(gl, indices, gl.ELEMENT_ARRAY_BUFFER);\n    bufferInfo.numElements = indices.length;\n  } else {\n    bufferInfo.numElements = getNumElementsFromNonIndexedArrays(arrays);\n  }\n\n  return bufferInfo;\n}\n\n/**\n * Creates buffers from typed arrays\n *\n * Given something like this\n *\n *     let arrays = {\n *        positions: [1, 2, 3],\n *        normals: [0, 0, 1],\n *     }\n *\n * returns something like\n *\n *     buffers = {\n *       positions: WebGLBuffer,\n *       normals: WebGLBuffer,\n *     }\n *\n * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.\n *\n * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n * @param {Object<string, array|typedarray>} arrays\n * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array\n * @memberOf module:webgl-utils\n */\nfunction createBuffersFromArrays(gl, arrays) {\n  const buffers = {};\n  Object.keys(arrays).forEach(function (key) {\n    const type = key === 'indices' ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n    const array = makeTypedArray(arrays[key], name);\n    buffers[key] = createBufferFromTypedArray(gl, array, type);\n  });\n\n  // hrm\n  if (arrays.indices) {\n    buffers.numElements = arrays.indices.length;\n  } else if (arrays.position) {\n    buffers.numElements = arrays.position.length / 3;\n  }\n\n  return buffers;\n}\n\n/**\n * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate\n *\n * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself\n * but calling this means if you switch from indexed data to non-indexed\n * data you don't have to remember to update your draw call.\n *\n * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n * @param {module:webgl-utils.BufferInfo} bufferInfo as returned from createBufferInfoFromArrays\n * @param {enum} [primitiveType] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...)\n * @param {number} [count] An optional count. Defaults to bufferInfo.numElements\n * @param {number} [offset] An optional offset. Defaults to 0.\n * @memberOf module:webgl-utils\n */\nfunction drawBufferInfo(gl, bufferInfo, primitiveType, count, offset) {\n  const indices = bufferInfo.indices;\n  primitiveType = primitiveType === undefined ? gl.TRIANGLES : primitiveType;\n  const numElements = count === undefined ? bufferInfo.numElements : count;\n  offset = offset === undefined ? 0 : offset;\n  if (indices) {\n    gl.drawElements(primitiveType, numElements, gl.UNSIGNED_SHORT, offset);\n  } else {\n    gl.drawArrays(primitiveType, offset, numElements);\n  }\n}\n\n/**\n * @typedef {Object} DrawObject\n * @property {module:webgl-utils.ProgramInfo} programInfo A ProgramInfo as returned from createProgramInfo\n * @property {module:webgl-utils.BufferInfo} bufferInfo A BufferInfo as returned from createBufferInfoFromArrays\n * @property {Object<string, ?>} uniforms The values for the uniforms\n * @memberOf module:webgl-utils\n */\n\n/**\n * Draws a list of objects\n * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n * @param {DrawObject[]} objectsToDraw an array of objects to draw.\n * @memberOf module:webgl-utils\n */\nfunction drawObjectList(gl, objectsToDraw) {\n  let lastUsedProgramInfo = null;\n  let lastUsedBufferInfo = null;\n\n  objectsToDraw.forEach(function (object) {\n    const programInfo = object.programInfo;\n    const bufferInfo = object.bufferInfo;\n    let bindBuffers = false;\n\n    if (programInfo !== lastUsedProgramInfo) {\n      lastUsedProgramInfo = programInfo;\n      gl.useProgram(programInfo.program);\n      bindBuffers = true;\n    }\n\n    // Setup all the needed attributes.\n    if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {\n      lastUsedBufferInfo = bufferInfo;\n      setBuffersAndAttributes(gl, programInfo.attribSetters, bufferInfo);\n    }\n\n    // Set the uniforms.\n    setUniforms(programInfo.uniformSetters, object.uniforms);\n\n    // Draw\n    drawBufferInfo(gl, bufferInfo);\n  });\n}\n\nfunction glEnumToString(gl, v) {\n  const results = [];\n  for (const key in gl) {\n    if (gl[key] === v) {\n      results.push(key);\n    }\n  }\n  return results.length\n    ? results.join(' | ')\n    : `0x${v.toString(16)}`;\n}\n\nconst isIE = /*@cc_on!@*/false || !!document.documentMode;\n// Edge 20+\nconst isEdge = !isIE && !!window.StyleMedia;\nif (isEdge) {\n  // Hack for Edge. Edge's WebGL implmentation is crap still and so they\n  // only respond to \"experimental-webgl\". I don't want to clutter the\n  // examples with that so his hack works around it\n  HTMLCanvasElement.prototype.getContext = function (origFn) {\n    return function () {\n      let args = arguments;\n      const type = args[0];\n      if (type === 'webgl') {\n        args = [].slice.call(arguments);\n        args[0] = 'experimental-webgl';\n      }\n      return origFn.apply(this, args);\n    };\n  }(HTMLCanvasElement.prototype.getContext);\n}\n\nexport {\n  createAugmentedTypedArray,\n  createAttribsFromArrays,\n  createBuffersFromArrays,\n  createBufferInfoFromArrays,\n  createAttributeSetters,\n  createProgram,\n  createProgramFromScripts,\n  createProgramFromSources,\n  createProgramInfo,\n  createUniformSetters,\n  createVAOAndSetAttributes,\n  createVAOFromBufferInfo,\n  drawBufferInfo,\n  drawObjectList,\n  glEnumToString,\n  getExtensionWithKnownPrefixes,\n  loadShader,\n  resizeCanvasToDisplaySize,\n  setAttributes,\n  setBuffersAndAttributes,\n  setUniforms,\n};\n"],"sourceRoot":""}