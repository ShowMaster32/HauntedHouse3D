<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js - Room with Skybox, Windows, and Door</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
    <div id="container"></div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "../build/three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>
    
    <script type="module">
        
        import * as THREE from 'three';
        import Stats from 'three/addons/libs/stats.module.js';
        import { Octree } from 'three/addons/math/Octree.js';
        import { Capsule } from 'three/addons/math/Capsule.js';
        
        const clock = new THREE.Clock();
        
        const scene = new THREE.Scene();
        
        // Configurazione della skybox
        const loader = new THREE.CubeTextureLoader();
        const texture = loader.load([
            'textures/skybox/px.png', // Positivo X
            'textures/skybox/nx.png', // Negativo X
            'textures/skybox/py.png', // Positivo Y
            'textures/skybox/ny.png', // Negativo Y
            'textures/skybox/pz.png', // Positivo Z
            'textures/skybox/nz.png'  // Negativo Z
        ]);
        scene.background = texture;
        
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.rotation.order = 'YXZ';
        
        const fillLight1 = new THREE.HemisphereLight(0x8dc1de, 0x00668d, 1.5);
        fillLight1.position.set(2, 1, 1);
        scene.add(fillLight1);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
        directionalLight.position.set(-5, 25, -1);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        const container = document.getElementById('container');
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop(animate);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.VSMShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);
        
        const stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild(stats.domElement);
        
        const GRAVITY = 30;
        const STEPS_PER_FRAME = 5;
        
        const worldOctree = new Octree();
        
        const playerCollider = new Capsule(new THREE.Vector3(0, 0.35, 0), new THREE.Vector3(0, 4, 0), 0.35);
        const playerVelocity = new THREE.Vector3();
        const playerDirection = new THREE.Vector3();
        
        let playerOnFloor = false;
        
        const keyStates = {};
        
        document.addEventListener('keydown', (event) => {
            keyStates[event.code] = true;
        });
        
        document.addEventListener('keyup', (event) => {
            keyStates[event.code] = false;
        });
        
        container.addEventListener('mousedown', () => {
            document.body.requestPointerLock();
        });
        
        document.body.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= event.movementX / 500;
                camera.rotation.x -= event.movementY / 500;
            }
        });
        
        window.addEventListener('resize', onWindowResize);
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Creazione della stanza
        const roomWidth = 20;
        const roomHeight = 10;
        const roomDepth = 25;
        
        // Caricamento delle texture
        const textureLoader = new THREE.TextureLoader();
        const wallTexture = textureLoader.load('textures/wall.jpg');
        const floorTexture = textureLoader.load('textures/wood.jpg');
        
        // Materiali per le pareti, pavimento e finestre
        const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture });
        const floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture });
        const glassMaterial = new THREE.MeshBasicMaterial({ color: 0x88ccee, opacity: 0.3, transparent: true, side: THREE.DoubleSide });
        
        // Creazione dei muri con finestre e porta
        function createWallWithWindowAndDoor() {
            // Parete frontale con finestra
            const frontWall1 = new THREE.Mesh(new THREE.BoxGeometry(7, roomHeight, 0.1), wallMaterial);
            frontWall1.position.set(-6.5, roomHeight / 2, -roomDepth / 2);
            scene.add(frontWall1);
            
            const frontWall2 = new THREE.Mesh(new THREE.BoxGeometry(7, roomHeight, 0.1), wallMaterial);
            frontWall2.position.set(6.5, roomHeight / 2, -roomDepth / 2);
            scene.add(frontWall2);
            
            const frontWindow = new THREE.Mesh(new THREE.PlaneGeometry(4, 6), glassMaterial);
            frontWindow.position.set(0, roomHeight / 2, -roomDepth / 2);
            scene.add(frontWindow);
            
            // Parete posteriore con finestra
            const backWall1 = new THREE.Mesh(new THREE.BoxGeometry(7, roomHeight, 0.1), wallMaterial);
            backWall1.position.set(-6.5, roomHeight / 2, roomDepth / 2);
            scene.add(backWall1);
            
            const backWall2 = new THREE.Mesh(new THREE.BoxGeometry(7, roomHeight, 0.1), wallMaterial);
            backWall2.position.set(6.5, roomHeight / 2, roomDepth / 2);
            scene.add(backWall2);
            
            const backWindow = new THREE.Mesh(new THREE.PlaneGeometry(6, 4), glassMaterial);
            backWindow.position.set(0, roomHeight / 2, roomDepth / 2);
            backWindow.rotation.z = Math.PI / 2;  // Rotazione di 90 gradi
            scene.add(backWindow);
            
			// Parete sinistra con porta
			const leftWall1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, roomHeight, 6), wallMaterial);
			leftWall1.position.set(-roomWidth / 2, roomHeight / 2, 7.5);
			scene.add(leftWall1);

			const leftWall2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, roomHeight, 6), wallMaterial);
			leftWall2.position.set(-roomWidth / 2, roomHeight / 2, -7.5);
			scene.add(leftWall2);

			const door = new THREE.Mesh(new THREE.PlaneGeometry(4, 7), glassMaterial);
			door.position.set(-roomWidth / 2, roomHeight / 2 - 1.5, 0);
			door.rotation.y = Math.PI / 2;  // Rotazione di 90 gradi
			scene.add(door);
            
			// Parete destra con finestra
			const rightWall1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, roomHeight, 7), wallMaterial);
			rightWall1.position.set(roomWidth / 2, roomHeight / 2, 8);
			scene.add(rightWall1);

			const rightWall2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, roomHeight, 7), wallMaterial);
			rightWall2.position.set(roomWidth / 2, roomHeight / 2, -8);
			scene.add(rightWall2);

			const rightWindow = new THREE.Mesh(new THREE.PlaneGeometry(6, 4), glassMaterial);
			rightWindow.position.set(roomWidth / 2, roomHeight / 2, 0);
			rightWindow.rotation.y = -Math.PI / 2;  // Rotazione di -90 gradi
			rightWindow.rotation.z = -Math.PI / 2;  // Rotazione di -90 gradi
			scene.add(rightWindow);
        }
        
        createWallWithWindowAndDoor();
        
        // Pavimento
        const floor = new THREE.Mesh(new THREE.BoxGeometry(roomWidth, 0.1, roomDepth), floorMaterial);
        floor.position.set(0, 0, 0);
        scene.add(floor);
        
        // Soffitto
        const ceiling = floor.clone();
        ceiling.position.set(0, roomHeight, 0);
        scene.add(ceiling);
        
        // Aggiunta delle pareti e del pavimento all'Octree per le collisioni
        worldOctree.fromGraphNode(scene);
        
        function playerCollisions() {
            const result = worldOctree.capsuleIntersect(playerCollider);
            playerOnFloor = false;
            if (result) {
                playerOnFloor = result.normal.y > 0;
                if (!playerOnFloor) {
                    playerVelocity.addScaledVector(result.normal, -result.normal.dot(playerVelocity));
                }
                if (result.depth >= 1e-10) {
                    playerCollider.translate(result.normal.multiplyScalar(result.depth));
                }
            }
        }
        
        function updatePlayer(deltaTime) {
            let damping = Math.exp(-4 * deltaTime) - 1;
            if (!playerOnFloor) {
                playerVelocity.y -= GRAVITY * deltaTime;
                damping *= 0.1;
            }
            playerVelocity.addScaledVector(playerVelocity, damping);
            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerCollider.translate(deltaPosition);
            playerCollisions();
            camera.position.copy(playerCollider.end);
        }
        
        function getForwardVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            return playerDirection;
        }
        
        function getSideVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            playerDirection.cross(camera.up);
            return playerDirection;
        }
        
        function controls(deltaTime) {
            const speedDelta = deltaTime * (playerOnFloor ? 25 : 8);
            if (keyStates['KeyW']) {
                playerVelocity.add(getForwardVector().multiplyScalar(speedDelta));
            }
            if (keyStates['KeyS']) {
                playerVelocity.add(getForwardVector().multiplyScalar(-speedDelta));
            }
            if (keyStates['KeyA']) {
                playerVelocity.add(getSideVector().multiplyScalar(-speedDelta));
            }
            if (keyStates['KeyD']) {
                playerVelocity.add(getSideVector().multiplyScalar(speedDelta));
            }
            if (playerOnFloor) {
                if (keyStates['Space']) {
                    playerVelocity.y = 10;
                }
            }
        }
        
        function teleportPlayerIfOob() {
            if (camera.position.y <= -20) {
                playerCollider.start.set(0, 0.35, 0);
                playerCollider.end.set(0, 4, 0);
                playerCollider.radius = 0.35;
                camera.position.copy(playerCollider.end);
                camera.rotation.set(0, 0, 0);
            }
        }
        
        function animate() {
            const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;
            for (let i = 0; i < STEPS_PER_FRAME; i++) {
                controls(deltaTime);
                updatePlayer(deltaTime);
                teleportPlayerIfOob();
            }
            renderer.render(scene, camera);
            stats.update();
        }
        
    </script>
</body>
</html>
