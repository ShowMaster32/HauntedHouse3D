<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js - Room with Skybox, Windows, and Door</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
    <div id="container"></div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "./build/three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import Stats from 'three/addons/libs/stats.module.js';
        import { Capsule } from 'three/addons/math/Capsule.js';
        import { Octree } from 'three/addons/math/Octree.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

        const clock = new THREE.Clock();
        const scene = new THREE.Scene();

        // Configurazione della skybox
        const loader = new THREE.CubeTextureLoader();
        const texture = loader.load([
            'textures/skybox/px.png', // Positivo X
            'textures/skybox/nx.png', // Negativo X
            'textures/skybox/py.png', // Positivo Y
            'textures/skybox/ny.png', // Negativo Y
            'textures/skybox/pz.png', // Positivo Z
            'textures/skybox/nz.png'  // Negativo Z
        ]);
        scene.background = texture;

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.rotation.order = 'YXZ';

        const fillLight1 = new THREE.HemisphereLight(0x8dc1de, 0x00668d, 1.5);
        fillLight1.position.set(2, 1, 1);
        scene.add(fillLight1);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
        directionalLight.position.set(-5, 25, -1);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        const container = document.getElementById('container');

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop(animate);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.VSMShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);

        const stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild(stats.domElement);

        const GRAVITY = 30;
        const STEPS_PER_FRAME = 5;

        const worldOctree = new Octree();

        const playerCollider = new Capsule(new THREE.Vector3(0, 0.35, 0), new THREE.Vector3(0, 4, 0), 0.35);
        const playerVelocity = new THREE.Vector3();
        const playerDirection = new THREE.Vector3();

        let playerOnFloor = false;

        const keyStates = {};

        document.addEventListener('keydown', (event) => {
            keyStates[event.code] = true;
        });

        document.addEventListener('keyup', (event) => {
            keyStates[event.code] = false;
        });

        container.addEventListener('mousedown', () => {
            document.body.requestPointerLock();
        });

        document.body.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= event.movementX / 500;
                camera.rotation.x -= event.movementY / 500;
            }
        });

        window.addEventListener('resize', onWindowResize);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

		// Creazione della stanza
		const roomWidth = 20;
		const roomHeight = 10;
		const roomDepth = 25;

		const wallThickness = 0.1;
		const windowWidth = 6;
		const windowHeight = 4;
		const doorWidth = 4;
		const doorHeight = 8;

		const textureLoader = new THREE.TextureLoader();
		const wallTexture = textureLoader.load('textures/wall.jpg');
		const floorTexture = textureLoader.load('textures/wood.jpg');
		const doorTexture = textureLoader.load('textures/door.png');

		const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture });
		const floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture });
		const glassMaterial = new THREE.MeshBasicMaterial({ color: 0x88ccee, opacity: 0.3, transparent: true, side: THREE.DoubleSide });
		const doorMaterial = new THREE.MeshBasicMaterial({ map: doorTexture });

        // Caricamento del modello OBJ con MTL
        const mtlLoader = new MTLLoader();
        const objLoader = new OBJLoader();

        mtlLoader.load('models/haunted_statue.mtl', (materials) => {
            materials.preload();
            objLoader.setMaterials(materials);
            objLoader.load('models/haunted_statue.obj', (object) => {
                object.position.set(0, 0, 0);
                object.scale.set(0.3, 0.3, 0.3);
                scene.add(object);
            });
        });

        // Caricamento di altri OBJ

		// Caricamento del modello OBJ della bambola
		const dollTexture = textureLoader.load('models/Doll_Doll_BaseColor.png');

		objLoader.load('models/doll.obj', (object) => {
			object.traverse((child) => {
				if (child.isMesh) {
					child.material.map = dollTexture; 
					child.material.needsUpdate = true;
				}
			});

			object.position.set((Math.random() - 0.5) * roomWidth, 0, (Math.random() - 0.5) * roomDepth);
			object.scale.set(1, 1, 1);
			scene.add(object);
		});

		// Caricamento del modello OBJ della carrozzina 1
		const wheelchair1Texture = textureLoader.load('models/Doll_Doll_BaseColor.png');

		objLoader.load('models/kurumaisu.unity_1.obj', (object) => {
			object.traverse((child) => {
				if (child.isMesh) {
					child.material.map = wheelchair1Texture; 
					child.material.needsUpdate = true;
				}
			});

			// Posizionamento vicino al bordo sinistro della stanza
			object.position.set(-roomWidth + 10.5, -2.5, -roomDepth / 2 + 8);
			object.rotation.set(0, -Math.PI / 2, 0);
			object.scale.set(0.2, 0.2, 0.2);
			scene.add(object);
		});

		// Caricamento del modello OBJ della carrozzina 2
		const wheelchair2Texture = textureLoader.load('models/Doll_Doll_BaseColor.png');

		objLoader.load('models/UnsavedScene_1.obj', (object) => {
			object.traverse((child) => {
				if (child.isMesh) {
					child.material.map = wheelchair2Texture; 
					child.material.needsUpdate = true;
				}
			});

			object.position.set(-roomWidth / 2 + 20, -2, -roomDepth / 2 + 8);
			object.rotation.set(0, Math.PI -30 / 2, 0);
			object.scale.set(0.2, 0.2, 0.2);
			scene.add(object);
		});

        // Aggiunta di teschi posizionati lungo le pareti della stanza
        function addSkull(position, rotation, scale) {
            mtlLoader.load('models/12140_Skull_v3_L2.mtl', (materials) => {
                materials.preload();
                objLoader.setMaterials(materials);

                objLoader.load('models/12140_Skull_v3_L2.obj', (object) => {
                    object.position.set(position.x, position.y, position.z);
                    object.scale.set(scale, scale, scale);
                    object.rotation.set(rotation.x, rotation.y, rotation.z);
                    scene.add(object);
                });
            });
        }

        // Teschio sul muro frontale sinistro
        addSkull(
            { x: -8, y: 0, z: -11.0 },
            { x: -Math.PI / 2, y: 0, z: 0 },
            0.05
        );
        addSkull(
            { x: -8, y: 1.5, z: -10.8 },
            { x: -Math.PI / 2 + 0.4, y: 0.2, z: 0.5 },
            0.06
        );
        addSkull(
            { x: -8, y: 3.3, z: -10.9 },
            { x: -Math.PI / 2 + 0.2, y: 1.3, z: -0.15 },
            0.05
        );

        // Teschio sul muro frontale destro
        addSkull(
            { x: 8, y: 0.2, z: -10.9 },
            { x: -Math.PI / 2 + 0.1, y: 0, z: 0 },
            0.06
        );
        addSkull(
            { x: 8, y: 1.8, z: -10.6 },
            { x: -Math.PI / 2 + 0.3, y: 0, z: -0.3 },
            0.07
        );

        // Teschio sulla parete posteriore sinistra
        addSkull(
            { x: -8, y: 0, z: 11.3 },
            { x: Math.PI / 2, y: Math.PI, z: 0 },
            0.08
        );
        addSkull(
            { x: -8, y: 2, z: 11.3 },
            { x: Math.PI / 2 + 0.1, y: Math.PI, z: 0.2 },
            0.07
        );

        // Teschio sulla parete posteriore destra
        addSkull(
            { x: 7.7, y: 0, z: 11.3 },
            { x: Math.PI / 2, y: Math.PI, z: 0 },
            0.06
        );
        addSkull(
            { x: 8, y: 1.4, z: 11.3 },
            { x: Math.PI / 2 + 0.3, y: Math.PI, z: 0 },
            0.07
        );
        addSkull(
            { x: 7.8, y: 2.8, z: 11.3 },
            { x: Math.PI / 2 + 0.3, y: Math.PI, z: 0.1 },
            0.07
        );

        // Teschio sul muro laterale sinistro, sopra la porta
        addSkull(
            { x: -10, y: doorHeight + 0.5, z: 0 },
            { x: -Math.PI / 2, y: Math.PI / 2, z: 0 },
            0.05
        );

        // Teschio sul muro laterale destro
        addSkull(
            { x: 10, y: 0.7, z: 4 },
            { x: -Math.PI / 2, y: -Math.PI / 2 - 0.1, z: 2 },
            0.05
        );

        function createWallWithWindowAndDoor() {
            const frontWallTop = new THREE.Mesh(
            new THREE.BoxGeometry(windowWidth, (roomHeight - windowHeight) / 2, wallThickness), wallMaterial);
            frontWallTop.position.set(0, roomHeight - (roomHeight - windowHeight) / 4, -roomDepth / 2);
            scene.add(frontWallTop);

            const frontWallBottom = new THREE.Mesh(new THREE.BoxGeometry(windowWidth, (roomHeight - windowHeight) / 2, wallThickness), wallMaterial);
            frontWallBottom.position.set(0, (roomHeight - windowHeight) / 4, -roomDepth / 2);
            scene.add(frontWallBottom);

            const frontWallLeft = new THREE.Mesh(new THREE.BoxGeometry((roomWidth - windowWidth) / 2, roomHeight, wallThickness), wallMaterial);
            frontWallLeft.position.set(-((roomWidth - windowWidth) / 4 + windowWidth / 2), roomHeight / 2, -roomDepth / 2);
            scene.add(frontWallLeft);

            const frontWallRight = new THREE.Mesh(new THREE.BoxGeometry((roomWidth - windowWidth) / 2, roomHeight, wallThickness), wallMaterial);
            frontWallRight.position.set(((roomWidth - windowWidth) / 4 + windowWidth / 2), roomHeight / 2, -roomDepth / 2);
            scene.add(frontWallRight);

            const frontWindow = new THREE.Mesh(new THREE.PlaneGeometry(windowWidth, windowHeight), glassMaterial);
            frontWindow.position.set(0, roomHeight / 2, -roomDepth / 2 + wallThickness / 2);
            scene.add(frontWindow);

            const backWallTop = new THREE.Mesh(
            new THREE.BoxGeometry(windowWidth, (roomHeight - windowHeight) / 2, wallThickness), wallMaterial);
            backWallTop.position.set(0, roomHeight - (roomHeight - windowHeight) / 4, roomDepth / 2);
            scene.add(backWallTop);

            const backWallBottom = new THREE.Mesh(new THREE.BoxGeometry(windowWidth, (roomHeight - windowHeight) / 2, wallThickness), wallMaterial);
            backWallBottom.position.set(0, (roomHeight - windowHeight) / 4, roomDepth / 2);
            scene.add(backWallBottom);

            const backWallLeft = new THREE.Mesh(new THREE.BoxGeometry((roomWidth - windowWidth) / 2, roomHeight, wallThickness), wallMaterial);
            backWallLeft.position.set(-((roomWidth - windowWidth) / 4 + windowWidth / 2), roomHeight / 2, roomDepth / 2);
            scene.add(backWallLeft);

            const backWallRight = new THREE.Mesh(new THREE.BoxGeometry((roomWidth - windowWidth) / 2, roomHeight, wallThickness), wallMaterial);
            backWallRight.position.set(((roomWidth - windowWidth) / 4 + windowWidth / 2), roomHeight / 2, roomDepth / 2);
            scene.add(backWallRight);

            const backWindow = new THREE.Mesh(new THREE.PlaneGeometry(windowWidth, windowHeight), glassMaterial);
            backWindow.position.set(0, roomHeight / 2, roomDepth / 2 + wallThickness / 2);
            scene.add(backWindow);

            const leftWallTop = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, roomHeight - doorHeight, doorWidth), wallMaterial);
            leftWallTop.position.set(-roomWidth / 2, roomHeight - (roomHeight - doorHeight) / 2, 0);
            scene.add(leftWallTop);

            const leftWallLeft = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, roomHeight, (roomDepth - doorWidth) / 2), wallMaterial);
            leftWallLeft.position.set(-roomWidth / 2, roomHeight / 2, (roomDepth - doorWidth) / 4 + doorWidth / 2);
            scene.add(leftWallLeft);

            const leftWallRight = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, roomHeight, (roomDepth - doorWidth) / 2), wallMaterial);
            leftWallRight.position.set(-roomWidth / 2, roomHeight / 2, -(roomDepth - doorWidth) / 4 - doorWidth / 2);
            scene.add(leftWallRight);

            const door = new THREE.Mesh(new THREE.PlaneGeometry(doorWidth, doorHeight), doorMaterial);
            door.position.set(-roomWidth / 2 + wallThickness / 2, doorHeight / 2, 0);
            door.rotation.y = Math.PI / 2;
            scene.add(door);

            const rightWallTop = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, (roomHeight - windowHeight) / 2, windowWidth), wallMaterial);
            rightWallTop.position.set(roomWidth / 2, roomHeight - (roomHeight - windowHeight) / 4, 0);
            scene.add(rightWallTop);

            const rightWallBottom = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, (roomHeight - windowHeight) / 2, windowWidth), wallMaterial);
            rightWallBottom.position.set(roomWidth / 2, (roomHeight - windowHeight) / 4, 0);
            scene.add(rightWallBottom);

            const rightWallLeft = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, roomHeight, (roomDepth - windowWidth) / 2), wallMaterial);
            rightWallLeft.position.set(roomWidth / 2, roomHeight / 2, (roomDepth - windowWidth) / 4 + windowWidth / 2);
            scene.add(rightWallLeft);

            const rightWallRight = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, roomHeight, (roomDepth - windowWidth) / 2), wallMaterial);
            rightWallRight.position.set(roomWidth / 2, roomHeight / 2, -(roomDepth - windowWidth) / 4 - windowWidth / 2);
            scene.add(rightWallRight);

            const rightWindow = new THREE.Mesh(new THREE.PlaneGeometry(windowWidth, windowHeight), glassMaterial);
            rightWindow.position.set(roomWidth / 2 + wallThickness / 2, roomHeight / 2, 0);
            rightWindow.rotation.y = -Math.PI / 2;
            scene.add(rightWindow);
        }

        createWallWithWindowAndDoor();

        // Pavimento
        const floor = new THREE.Mesh(new THREE.BoxGeometry(roomWidth, 0.1, roomDepth), floorMaterial);
        floor.position.set(0, 0, 0);
        scene.add(floor);

        // Soffitto
        const ceiling = floor.clone();
        ceiling.position.set(0, roomHeight, 0);
        scene.add(ceiling);

        // Aggiunta delle pareti e del pavimento all'Octree per le collisioni
        worldOctree.fromGraphNode(scene);

        function playerCollisions() {
            const result = worldOctree.capsuleIntersect(playerCollider);
            playerOnFloor = false;
            if (result) {
                playerOnFloor = result.normal.y > 0;
                if (!playerOnFloor) {
                    playerVelocity.addScaledVector(result.normal, -result.normal.dot(playerVelocity));
                }
                if (result.depth >= 1e-10) {
                    playerCollider.translate(result.normal.multiplyScalar(result.depth));
                }
            }
        }

        function updatePlayer(deltaTime) {
            let damping = Math.exp(-4 * deltaTime) - 1;
            if (!playerOnFloor) {
                playerVelocity.y -= GRAVITY * deltaTime;
                damping *= 0.1;
            }
            playerVelocity.addScaledVector(playerVelocity, damping);
            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerCollider.translate(deltaPosition);
            playerCollisions();
            camera.position.copy(playerCollider.end);
        }

        function getForwardVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            return playerDirection;
        }

        function getSideVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            playerDirection.cross(camera.up);
            return playerDirection;
        }

        function controls(deltaTime) {
            const speedDelta = deltaTime * (playerOnFloor ? 25 : 8);
            if (keyStates['KeyW']) {
                playerVelocity.add(getForwardVector().multiplyScalar(speedDelta));
            }
            if (keyStates['KeyS']) {
                playerVelocity.add(getForwardVector().multiplyScalar(-speedDelta));
            }
            if (keyStates['KeyA']) {
                playerVelocity.add(getSideVector().multiplyScalar(-speedDelta));
            }
            if (keyStates['KeyD']) {
                playerVelocity.add(getSideVector().multiplyScalar(speedDelta));
            }
            if (playerOnFloor) {
                if (keyStates['Space']) {
                    playerVelocity.y = 10;
                }
            }
        }

        function teleportPlayerIfOob() {
            if (camera.position.y <= -20) {
                playerCollider.start.set(0, 0.35, 0);
                playerCollider.end.set(0, 4, 0);
                playerCollider.radius = 0.35;
                camera.position.copy(playerCollider.end);
                camera.rotation.set(0, 0, 0);
            }
        }

        function animate() {
            const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;
            for (let i = 0; i < STEPS_PER_FRAME; i++) {
                controls(deltaTime);
                updatePlayer(deltaTime);
                teleportPlayerIfOob();
            }
            renderer.render(scene, camera);
            stats.update();
        }

    </script>
</body>
</html>
